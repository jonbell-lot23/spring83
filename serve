#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const cheerio = require('cheerio');
const ed = require('@noble/ed25519');
const mustache = require('mustache');
const app = require('fastify')({ logger: true });
const { constants, pubKeyHexIsValid } = require('./common');

const expectPutHeaders = Object.freeze({
  'content-type': constants.contentType,
  'spring-version': constants.protocolVersion,
  'if-unmodified-since': (v, context) => {
    if (context?.multipleUnmodifiedSinceHeaders) {
      return 400;
    }

    const parsed = Date.parse(v);

    if (Number.isNaN(parsed)) {
      return 400;
    }

    const parsedDate = new Date(parsed);
    const checkTime = new Date(Date.now() + constants.unmodifiedSinceTimeFudgeMs);

    if (parsedDate > checkTime) {
      return 400;
    }

    context.multipleUnmodifiedSinceHeaders = 1;
    context.ifUnmodifiedSinceUNIXTime = parsed;
  },
  authorization: async (v, context) => {
    if (v.indexOf('=') === -1) {
      return 400;
    }

    const [preamble, sigHex] = v.split('=');

    if (preamble !== constants.authorizationPreamble) {
      return 400;
    }

    return !(await ed.verify(sigHex, Buffer.from(context.body), context.key));
  },
  'content-length': (v) => {
    const vp = Number.parseInt(v);
    if (!Number.isNaN(vp) && vp > constants.maximumContentLength) {
      return 413;
    }
  }
});

const initialPutChecks = Object.freeze({
  'missing body or key': (req) => !req.body || !req.params.key,
  'invalid pub key': (req) => !pubKeyHexIsValid(req.params.key, true),
  'missing header(s)': (req) => !allExpectedHeadersExist(expectPutHeaders, req),
  'missing required <meta> tag attribute(s)': (req) => !documentHasRequiredMeta(req)
});

function documentHasRequiredMeta (req) {
  return Date.parse(cheerio.load(req.body)('meta[http-equiv=last-modified]')?.attr()?.content);
}

async function validateHeader (context, [header, val]) {
  const validator = expectPutHeaders?.[header];
  return [header, val, await {
    string: async () => !(val === validator),
    function: async () => validator(val, context)
  }?.[typeof validator]?.()];
}

function allExpectedHeadersExist (expectedMap, req) {
  return Object.keys(expectedMap).every(k => Boolean(req.headers[k]));
}

function applyGenericGETReplyHeaders (reply, isRoot = false) {
  reply.type(constants.contentType);
  reply.header('Spring-Version', constants.protocolVersion);

  if (!isRoot) {
    reply.header('Content-Security-Policy', Object.entries({
      none: ['script-src', 'script-src-attr', 'script-src-elem',
        'child-src', 'frame-src', 'prefetch-src', ' object-src'],
      'data:': ['img-src']
    }).reduce((a, [policyValue, directivesList]) => {
      let emitValue = policyValue;
      if (policyValue.indexOf(':') === -1) {
        emitValue = `'${policyValue}'`;
      }
      return (a += directivesList.map((directive) => `${directive} ${emitValue};`).join(' ') + ' ');
    }, ''));
  }
}

async function findKnownKeys (contentDir) {
  return (await Promise.all((await fs.promises.readdir(contentDir)).filter((p) => {
    const parsed = path.parse(p);
    return parsed.name.match(constants.keyMatchRegex) && parsed.ext === '.html';
  })
    .map(path.parse)
    .map(async (pObj) => ([
      pObj.name,
      (await fs.promises.readFile(path.join(contentDir, pObj.name + pObj.ext))).toString('utf8'),
      JSON.parse(await fs.promises.readFile(path.join(contentDir, pObj.name + '.json')))
    ]))))
    .reduce((a, [key, body, metadata]) => ({ [key]: { body, metadata }, ...a }), {});
}

async function main () {
  const rootTmpl = (await fs.promises.readFile(path.join(__dirname, 'root.tmpl.html'))).toString('utf8');
  const contentDir = path.resolve(process.env.SPRING83_CONTENT_DIR || path.join(__dirname, '.content'));
  await fs.promises.mkdir(contentDir, { recursive: true });

  const knownKeys = await findKnownKeys(contentDir);
  app.log.info(`Found ${Object.keys(knownKeys).length} pre-existing boards`);

  const getCurrentDifficultyFactor = () => (Object.keys(knownKeys).length / constants.maximumNumberOfBoards) ** 4;

  app.addContentTypeParser('text/html', { parseAs: 'string' }, (req, body, done) => done(null, body));

  app.put('/:key', async (req, reply) => {
    const putCheckRes = Object.entries(initialPutChecks)
      .find(([, checkFunc]) => checkFunc(req));

    if (putCheckRes) {
      app.log.warn(putCheckRes[0]);
      reply.code(400);
      return;
    }

    const pathPrefix = path.join(contentDir, req.params.key);

    try {
      const { headers } = JSON.parse(await (await fs.promises.readFile(`${pathPrefix}.json`)).toString('utf8'));
      const metaCheck = documentHasRequiredMeta(req); // check in initialPutChecks prior, so will have a value

      if (metaCheck <= Date.parse(headers['if-unmodified-since'])) {
        reply.code(409);
        return;
      }
    } catch (err) {
      if (err.code !== 'ENOENT') {
        throw err;
      }
    }

    const validationContext = { body: req.body, key: req.params.key };
    const firstInvalid = (await Promise.all(Object.entries(req.headers)
      .map(validateHeader.bind(null, validationContext))))
      .find(([,, invalid]) => Boolean(invalid));

    if (firstInvalid) {
      const [invalidName, invalidValue, validatorResult] = firstInvalid;

      reply.code(400);
      if (typeof validatorResult === 'number') {
        reply.code(validatorResult);
      }

      app.log.warn(`bad header '${invalidName}: ${invalidValue}'`);
      return;
    }

    const writeOpts = { mode: 0o660 };
    const metadata = {
      headers: req.headers,
      ingest: new Date()
    };

    await fs.promises.writeFile(`${pathPrefix}.html`, req.body, writeOpts);
    await fs.promises.writeFile(`${pathPrefix}.json`, JSON.stringify(metadata), writeOpts);

    knownKeys[req.params.key] = {
      body: req.body,
      metadata
    };

    app.log.info(`New board posted! ${req.params.key}`);
  });

  app.get('/:key', async (req, reply) => {
    if (!pubKeyHexIsValid(req.params.key, true)) {
      app.log.warn('invalid key');
      reply.code(400);
      return;
    }

    applyGenericGETReplyHeaders(reply);
    return knownKeys[req.params.key].body;
  });

  app.get('/', async (req, reply) => {
    applyGenericGETReplyHeaders(reply, true);
    reply.header('Spring-Difficulty', getCurrentDifficultyFactor());
    return mustache.render(rootTmpl, {
      boards: Object.keys(knownKeys).map((key) => ({
        key,
        key_display: key.slice(0, 16)
      }))
    });
  });

  ['SIGINT', 'SIGTERM'].forEach((sig) => process.on(sig, () => {
    console.log('Stopping...');
    process.exit(0);
  }));

  await app.listen({
    port: process.env.SPRING83_BIND_PORT || 1783,
    host: process.env.SPRING83_BIND_HOST || '0.0.0.0'
  });
}

main();
